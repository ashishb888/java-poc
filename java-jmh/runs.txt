RUN 1: RandomBenchmark

[user@host java-jmh]$ $JAVA_HOME/bin/java -cp . -Xms1G -Xmx1G  java-jmh-0.0.1-SNAPSHOT-jar-with-dependencies.jar
Error: Could not find or load main class java-jmh-0.0.1-SNAPSHOT-jar-with-dependencies.jar

----------

[user@host java-jmh]$ $JAVA_HOME/bin/java -cp . -Xms1G -Xmx1G  poc.java.service.MainService
# JMH version: 1.23
# VM version: JDK 1.8.0_191, Java HotSpot(TM) 64-Bit Server VM, 25.191-b12
# VM invoker: /opt/ngs/setups/jdk1.8.0_191/jre/bin/java
# VM options: -Xms1G -Xmx1G
# Warmup: 3 iterations, 5 s each
# Measurement: 3 iterations, 5 s each
# Timeout: 10 min per iteration
# Threads: 10 threads, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: poc.java.service.RandomBenchmark.random

# Run progress: 0.00% complete, ETA 00:01:00
# Fork: 1 of 1
# Warmup Iteration   1: 740.126 Â±(99.9%) 288.609 ns/op
# Warmup Iteration   2: 841.160 Â±(99.9%) 596.332 ns/op
# Warmup Iteration   3: 847.849 Â±(99.9%) 658.613 ns/op
Iteration   1: ^C^L[user@host java-jmh]$
[user@host java-jmh]$ $JAVA_HOME/bin/java -cp . -Xms1G -Xmx1G  poc.java.service.MainService
# JMH version: 1.23
# VM version: JDK 1.8.0_191, Java HotSpot(TM) 64-Bit Server VM, 25.191-b12
# VM invoker: /opt/ngs/setups/jdk1.8.0_191/jre/bin/java
# VM options: -Xms1G -Xmx1G
# Warmup: 3 iterations, 5 s each
# Measurement: 3 iterations, 5 s each
# Timeout: 10 min per iteration
# Threads: 10 threads, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: poc.java.service.RandomBenchmark.random

# Run progress: 0.00% complete, ETA 00:01:00
# Fork: 1 of 1
# Warmup Iteration   1: 772.581 Â±(99.9%) 466.766 ns/op
# Warmup Iteration   2: 833.687 Â±(99.9%) 587.261 ns/op
# Warmup Iteration   3: 806.788 Â±(99.9%) 564.344 ns/op
Iteration   1: 829.704 Â±(99.9%) 624.865 ns/op
Iteration   2: 766.497 Â±(99.9%) 427.560 ns/op
Iteration   3: 782.527 Â±(99.9%) 520.148 ns/op


Result "poc.java.service.RandomBenchmark.random":
  792.910 Â±(99.9%) 599.444 ns/op [Average]
  (min, avg, max) = (766.497, 792.910, 829.704), stdev = 32.858
  CI (99.9%): [193.466, 1392.353] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_191, Java HotSpot(TM) 64-Bit Server VM, 25.191-b12
# VM invoker: /opt/ngs/setups/jdk1.8.0_191/jre/bin/java
# VM options: -Xms1G -Xmx1G
# Warmup: 3 iterations, 5 s each
# Measurement: 3 iterations, 5 s each
# Timeout: 10 min per iteration
# Threads: 10 threads, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: poc.java.service.RandomBenchmark.threadLocalRandom

# Run progress: 50.00% complete, ETA 00:00:30
# Fork: 1 of 1
# Warmup Iteration   1: 7.062 Â±(99.9%) 0.181 ns/op
# Warmup Iteration   2: 7.427 Â±(99.9%) 0.125 ns/op
# Warmup Iteration   3: 6.253 Â±(99.9%) 0.050 ns/op
Iteration   1: 6.231 Â±(99.9%) 0.029 ns/op
Iteration   2: 6.231 Â±(99.9%) 0.025 ns/op
Iteration   3: 6.251 Â±(99.9%) 0.063 ns/op


Result "poc.java.service.RandomBenchmark.threadLocalRandom":
  6.238 Â±(99.9%) 0.214 ns/op [Average]
  (min, avg, max) = (6.231, 6.238, 6.251), stdev = 0.012
  CI (99.9%): [6.024, 6.452] (assumes normal distribution)


# Run complete. Total time: 00:01:00

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                          Mode  Cnt    Score     Error  Units
RandomBenchmark.random             avgt    3  792.910 Â± 599.444  ns/op
RandomBenchmark.threadLocalRandom  avgt    3    6.238 Â±   0.214  ns/op

----------==----------
RUN 2

String comparison vs byte array comparison

ashish@LAPTOP-0CGC34A5:/mnt/d/work/git/java-poc/java-jmh$ java -cp target/java-jmh-0.0.1-SNAPSHOT-jar-with-dependencies.jar -Xms512M -Xmx512M  poc.java.service.MainService
# JMH version: 1.23
# VM version: JDK 1.8.0_262, OpenJDK 64-Bit Server VM, 25.262-b10
# VM invoker: /home/ashish/.sdkman/candidates/java/8.0.262.hs-adpt/jre/bin/java
# VM options: -Xms512M -Xmx512M
# Warmup: 3 iterations, 5 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: poc.java.service.StringVsBytesComparison.bytesComparison

# Run progress: 0.00% complete, ETA 00:04:20
# Fork: 1 of 1
# Warmup Iteration   1: 0.011 ops/ns
# Warmup Iteration   2: 0.012 ops/ns
# Warmup Iteration   3: 0.011 ops/ns
Iteration   1: 0.011 ops/ns
Iteration   2: 0.012 ops/ns
Iteration   3: 0.011 ops/ns
Iteration   4: 0.011 ops/ns
Iteration   5: 0.011 ops/ns


Result "poc.java.service.StringVsBytesComparison.bytesComparison":
  0.011 ±(99.9%) 0.002 ops/ns [Average]
  (min, avg, max) = (0.011, 0.011, 0.012), stdev = 0.001
  CI (99.9%): [0.009, 0.013] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_262, OpenJDK 64-Bit Server VM, 25.262-b10
# VM invoker: /home/ashish/.sdkman/candidates/java/8.0.262.hs-adpt/jre/bin/java
# VM options: -Xms512M -Xmx512M
# Warmup: 3 iterations, 5 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: poc.java.service.StringVsBytesComparison.stringComparison

# Run progress: 25.00% complete, ETA 00:03:16
# Fork: 1 of 1
# Warmup Iteration   1: 0.324 ops/ns
# Warmup Iteration   2: 0.383 ops/ns
# Warmup Iteration   3: 0.471 ops/ns
Iteration   1: 0.462 ops/ns
Iteration   2: 0.470 ops/ns
Iteration   3: 0.469 ops/ns
Iteration   4: 0.468 ops/ns
Iteration   5: 0.468 ops/ns


Result "poc.java.service.StringVsBytesComparison.stringComparison":
  0.467 ±(99.9%) 0.012 ops/ns [Average]
  (min, avg, max) = (0.462, 0.467, 0.470), stdev = 0.003
  CI (99.9%): [0.455, 0.480] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_262, OpenJDK 64-Bit Server VM, 25.262-b10
# VM invoker: /home/ashish/.sdkman/candidates/java/8.0.262.hs-adpt/jre/bin/java
# VM options: -Xms512M -Xmx512M
# Warmup: 3 iterations, 5 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: poc.java.service.StringVsBytesComparison.bytesComparison

# Run progress: 50.00% complete, ETA 00:02:10
# Fork: 1 of 1
# Warmup Iteration   1: 95.636 ns/op
# Warmup Iteration   2: 91.349 ns/op
# Warmup Iteration   3: 91.470 ns/op
Iteration   1: 92.203 ns/op
Iteration   2: 91.821 ns/op
Iteration   3: 92.566 ns/op
Iteration   4: 91.913 ns/op
Iteration   5: 91.340 ns/op


Result "poc.java.service.StringVsBytesComparison.bytesComparison":
  91.969 ±(99.9%) 1.756 ns/op [Average]
  (min, avg, max) = (91.340, 91.969, 92.566), stdev = 0.456
  CI (99.9%): [90.213, 93.725] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_262, OpenJDK 64-Bit Server VM, 25.262-b10
# VM invoker: /home/ashish/.sdkman/candidates/java/8.0.262.hs-adpt/jre/bin/java
# VM options: -Xms512M -Xmx512M
# Warmup: 3 iterations, 5 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: poc.java.service.StringVsBytesComparison.stringComparison

# Run progress: 75.00% complete, ETA 00:01:05
# Fork: 1 of 1
# Warmup Iteration   1: 3.162 ns/op
# Warmup Iteration   2: 3.259 ns/op
# Warmup Iteration   3: 3.058 ns/op
Iteration   1: 2.368 ns/op
Iteration   2: 2.349 ns/op
Iteration   3: 2.553 ns/op
Iteration   4: 2.260 ns/op
Iteration   5: 2.286 ns/op


Result "poc.java.service.StringVsBytesComparison.stringComparison":
  2.363 ±(99.9%) 0.442 ns/op [Average]
  (min, avg, max) = (2.260, 2.363, 2.553), stdev = 0.115
  CI (99.9%): [1.921, 2.805] (assumes normal distribution)


# Run complete. Total time: 00:04:21

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                                  Mode  Cnt   Score   Error   Units
StringVsBytesComparison.bytesComparison   thrpt    5   0.011 ± 0.002  ops/ns
StringVsBytesComparison.stringComparison  thrpt    5   0.467 ± 0.012  ops/ns
StringVsBytesComparison.bytesComparison    avgt    5  91.969 ± 1.756   ns/op
StringVsBytesComparison.stringComparison   avgt    5   2.363 ± 0.442   ns/op


----------==----------
RUN 2: String comparison vs byte array comparison

In this run we are converting byte array to string and then we compare the strings

Benchmark                                  Mode  Cnt   Score    Error   Units
StringVsBytesComparison.bytesComparison   thrpt    5   0.010 ±  0.003  ops/ns
StringVsBytesComparison.stringComparison  thrpt    5   0.013 ±  0.001  ops/ns
StringVsBytesComparison.bytesComparison    avgt    5  92.488 ±  2.030   ns/op
StringVsBytesComparison.stringComparison   avgt    5  79.027 ±  1.319   ns/op